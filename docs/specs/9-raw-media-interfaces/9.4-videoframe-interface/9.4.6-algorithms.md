# 9.4.6. Algorithms

**Create a VideoFrame (with output, timestamp, duration, displayAspectWidth, displayAspectHeight, colorSpace, rotation, and flip)**
: 1. Let frame be a new [`VideoFrame`](#videoframe), constructed as follows:

    1.  Assign `false` to [`[[Detached]]`](https://html.spec.whatwg.org/multipage/structured-data.html#detached).

    2.  Let resource be the [media resource](#media-resource) described by output.

    3.  Let resourceReference be a reference to resource.

    4.  Assign resourceReference to [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).

    5.  If output uses a recognized [`VideoPixelFormat`](#enumdef-videopixelformat), assign that format to [`[[format]]`](#dom-videoframe-format-slot). Otherwise, assign `null` to [`[[format]]`](#dom-videoframe-format-slot).

    6.  Let codedWidth and codedHeight be the coded width and height of the output in pixels.

    7.  Let visibleLeft, visibleTop, visibleWidth, and visibleHeight be the left, top, width and height for the visible rectangle of output.

    8.  Let displayWidth and displayHeight be the display size of output in pixels.

    9.  If displayAspectWidth and displayAspectHeight are provided, increase displayWidth or displayHeight until the ratio of displayWidth to displayHeight matches the ratio of displayAspectWidth to displayAspectHeight.

    10.  Assign codedWidth, codedHeight, visibleLeft, visibleTop, visibleWidth, visibleHeight, displayWidth, and displayHeight to [`[[coded width]]`](#dom-videoframe-coded-width-slot), [`[[coded height]]`](#dom-videoframe-coded-height-slot), [`[[visible left]]`](#dom-videoframe-visible-left-slot), [`[[visible top]]`](#dom-videoframe-visible-top-slot), [`[[visible width]]`](#dom-videoframe-visible-width-slot), and [`[[visible height]]`](#dom-videoframe-visible-height-slot) respectively.

    11.  Assign duration and timestamp to [`[[duration]]`](#dom-videoframe-duration-slot) and [`[[timestamp]]`](#dom-videoframe-timestamp-slot) respectively.

    12.  Assign [`[[color space]]`](#dom-videoframe-color-space-slot) with the result of running the [Pick Color Space](#videoframe-pick-color-space) algorithm, with colorSpace and [`[[format]]`](#dom-videoframe-format-slot).

    13.  Assign [`rotation`](#dom-videoframe-rotation) and [`flip`](#dom-videoframe-flip) to rotation and flip respectively.

2.  Return frame.

**Pick Color Space (with overrideColorSpace and format)**
: 1. If overrideColorSpace is provided, return a new [`VideoColorSpace`](#videocolorspace) constructed with overrideColorSpace.

    User Agents _MAY_ replace `null` members of the provided overrideColorSpace with guessed values as determined by implementer defined heuristics.

2.  Otherwise, if [`[[format]]`](#dom-videoframe-format-slot) is an [RGB format](#rgb-format) return a new instance of the [sRGB Color Space](#srgb-color-space)
3.  Otherwise, return a new instance of the [REC709 Color Space](#rec709-color-space).

**Validate VideoFrameInit (with format, codedWidth, and codedHeight):**
: 1. If [`visibleRect`](#dom-videoframeinit-visiblerect) [exists](https://infra.spec.whatwg.org/#map-exists):

    1.  Let validAlignment be the result of running the [Verify Rect Offset Alignment](#videoframe-verify-rect-offset-alignment) with format and visibleRect.

    2.  If validAlignment is `false`, return `false`.

    3.  If any attribute of [`visibleRect`](#dom-videoframeinit-visiblerect) is negative or not finite, return `false`.

    4.  If [`visibleRect`](#dom-videoframeinit-visiblerect).[`width`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-width) == `0` or [`visibleRect`](#dom-videoframeinit-visiblerect).[`height`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-height) == `0` return `false`.

    5.  If [`visibleRect`](#dom-videoframeinit-visiblerect).[`y`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-y) + [`visibleRect`](#dom-videoframeinit-visiblerect).[`height`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-height) > codedHeight, return `false`.

    6.  If [`visibleRect`](#dom-videoframeinit-visiblerect).[`x`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-x) + [`visibleRect`](#dom-videoframeinit-visiblerect).[`width`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-width) > codedWidth, return `false`.

2.  If codedWidth = 0 or codedHeight = 0,return `false`.
3.  If only one of [`displayWidth`](#dom-videoframeinit-displaywidth) or [`displayHeight`](#dom-videoframeinit-displayheight) [exists](https://infra.spec.whatwg.org/#map-exists), return `false`.
4.  If [`displayWidth`](#dom-videoframeinit-displaywidth) == `0` or [`displayHeight`](#dom-videoframeinit-displayheight) == `0`, return `false`.
5.  Return `true`.

**To check if a VideoFrameBufferInit is a valid VideoFrameBufferInit, run these steps:**
: 1. If [`codedWidth`](#dom-videoframebufferinit-codedwidth) = 0 or [`codedHeight`](#dom-videoframebufferinit-codedheight) = 0,return `false`.

2.  If any attribute of [`visibleRect`](#dom-videoframebufferinit-visiblerect) is negative or not finite, return `false`.
3.  If [`visibleRect`](#dom-videoframebufferinit-visiblerect).[`y`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-y) + [`visibleRect`](#dom-videoframebufferinit-visiblerect).[`height`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-height) > [`codedHeight`](#dom-videoframebufferinit-codedheight), return `false`.
4.  If [`visibleRect`](#dom-videoframebufferinit-visiblerect).[`x`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-x) + [`visibleRect`](#dom-videoframebufferinit-visiblerect).[`width`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-width) > [`codedWidth`](#dom-videoframebufferinit-codedwidth), return `false`.
5.  If only one of [`displayWidth`](#dom-videoframebufferinit-displaywidth) or [`displayHeight`](#dom-videoframebufferinit-displayheight) [exists](https://infra.spec.whatwg.org/#map-exists), return `false`.
6.  If [`displayWidth`](#dom-videoframebufferinit-displaywidth) = 0 or [`displayHeight`](#dom-videoframebufferinit-displayheight) = 0, return `false`.
7.  Return `true`.

**Initialize Frame From Other Frame (with init, frame, and otherFrame)**
: 1. Let format be otherFrame.[`format`](#dom-videoframe-format).

2.  If init.[`alpha`](#dom-videoframeinit-alpha) is [`discard`](#dom-alphaoption-discard), assign otherFrame.[`format`](#dom-videoframe-format)’s [equivalent opaque format](#equivalent-opaque-format) format.
3.  Let validInit be the result of running the [Validate VideoFrameInit](#validate-videoframeinit) algorithm with format and otherFrame’s [`[[coded width]]`](#dom-videoframe-coded-width-slot) and [`[[coded height]]`](#dom-videoframe-coded-height-slot).
4.  If validInit is `false`, throw a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
5.  Let resource be the [media resource](#media-resource) referenced by otherFrame’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).
6.  Assign a new reference for resource to frame’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).
7.  Assign the following attributes from otherFrame to frame: [`codedWidth`](#dom-videoframe-codedwidth), [`codedHeight`](#dom-videoframe-codedheight), [`colorSpace`](#dom-videoframe-colorspace).
8.  Let defaultVisibleRect be the result of performing the getter steps for [`visibleRect`](#dom-videoframe-visiblerect) on otherFrame.
9.  Let baseRotation and baseFlip be otherFrame’s [`[[rotation]]`](#dom-videoframe-rotation-slot) and [`[[flip]]`](#dom-videoframe-flip-slot), respectively.
10. Let defaultDisplayWidth and defaultDisplayHeight be otherFrame’s [`[[display width]]`](#dom-videoframe-display-width-slot) and [`[[display height]]`](#dom-videoframe-display-height-slot), respectively.
11. Run the [Initialize Visible Rect, Orientation, and Display Size](#videoframe-initialize-visible-rect-orientation-and-display-size) algorithm with init, frame, defaultVisibleRect, baseRotation, baseFlip, defaultDisplayWidth, and defaultDisplayHeight.
12. If [`duration`](#dom-videoframeinit-duration) [exists](https://infra.spec.whatwg.org/#map-exists) in init, assign it to frame’s [`[[duration]]`](#dom-videoframe-duration-slot). Otherwise, assign otherFrame.[`duration`](#dom-videoframe-duration) to frame’s [`[[duration]]`](#dom-videoframe-duration-slot).
13. If [`timestamp`](#dom-videoframeinit-timestamp) [exists](https://infra.spec.whatwg.org/#map-exists) in init, assign it to frame’s [`[[timestamp]]`](#dom-videoframe-timestamp-slot). Otherwise, assign otherFrame’s [`timestamp`](#dom-videoframe-timestamp) to frame’s [`[[timestamp]]`](#dom-videoframe-timestamp-slot).
14. Assign format to frame.[`[[format]]`](#dom-videoframe-format-slot).
15. Assign the result of calling [Copy VideoFrame metadata](#videoframe-copy-videoframe-metadata) with init’s [`metadata`](#dom-videoframeinit-metadata) to frame.[`[[metadata]]`](#dom-videoframe-metadata-slot).

**Initialize Frame With Resource (with init, frame, resource, codedWidth, codedHeight, baseRotation, baseFlip, defaultDisplayWidth, and defaultDisplayHeight)**
: 1. Let format be `null`.

2.  If resource uses a recognized [`VideoPixelFormat`](#enumdef-videopixelformat), assign the [`VideoPixelFormat`](#enumdef-videopixelformat) of resource to format.
3.  Let validInit be the result of running the [Validate VideoFrameInit](#validate-videoframeinit) algorithm with format, width and height.
4.  If validInit is `false`, throw a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
5.  Assign a new reference for resource to frame’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).
6.  If init.[`alpha`](#dom-videoframeinit-alpha) is [`discard`](#dom-alphaoption-discard), assign format’s [equivalent opaque format](#equivalent-opaque-format) to format.
7.  Assign format to [`[[format]]`](#dom-videoframe-format-slot)
8.  Assign codedWidth and codedHeight to frame’s [`[[coded width]]`](#dom-videoframe-coded-width-slot) and [`[[coded height]]`](#dom-videoframe-coded-height-slot) respectively.
9.  Let defaultVisibleRect be a new [`DOMRect`](https://www.w3.org/TR/geometry-1/#domrect) constructed with «\[ "x:" → `0`, "y" → `0`, "width" → codedWidth, "height" → codedHeight \]»
10. Run the [Initialize Visible Rect, Orientation, and Display Size](#videoframe-initialize-visible-rect-orientation-and-display-size) algorithm with init, frame, defaultVisibleRect, defaultDisplayWidth, and defaultDisplayHeight.
11. Assign `init`.[`duration`](#dom-videoframeinit-duration) to frame’s [`[[duration]]`](#dom-videoframe-duration-slot).
12. Assign `init`.[`timestamp`](#dom-videoframeinit-timestamp) to frame’s [`[[timestamp]]`](#dom-videoframe-timestamp-slot).
13. If resource has a known [`VideoColorSpace`](#videocolorspace), assign its value to [`[[color space]]`](#dom-videoframe-color-space-slot).
14. Otherwise, assign a new [`VideoColorSpace`](#videocolorspace), constructed with an empty [`VideoColorSpaceInit`](#dictdef-videocolorspaceinit), to [`[[color space]]`](#dom-videoframe-color-space-slot).

**Initialize Visible Rect, Orientation, and Display Size (with init, frame, defaultVisibleRect, baseRotation, baseFlip, defaultDisplayWidth and defaultDisplayHeight)**
: 1. Let visibleRect be defaultVisibleRect.

2.  If init.[`visibleRect`](#dom-videoframeinit-visiblerect) [exists](https://infra.spec.whatwg.org/#map-exists), assign it to visibleRect.
3.  Assign visibleRect’s [`x`](https://www.w3.org/TR/geometry-1/#dom-domrect-x), [`y`](https://www.w3.org/TR/geometry-1/#dom-domrect-y), [`width`](https://www.w3.org/TR/geometry-1/#dom-domrect-width), and [`height`](https://www.w3.org/TR/geometry-1/#dom-domrect-height), to frame’s [`[[visible left]]`](#dom-videoframe-visible-left-slot), [`[[visible top]]`](#dom-videoframe-visible-top-slot), [`[[visible width]]`](#dom-videoframe-visible-width-slot), and [`[[visible height]]`](#dom-videoframe-visible-height-slot) respectively.
4.  Let rotation be the result of running the [Parse Rotation](#videoframe-parse-rotation) algorithm, with init.[`rotation`](#dom-videoframeinit-rotation).
5.  Assign the result of running the [Add Rotations](#videoframe-add-rotations) algorithm, with baseRotation, baseFlip, and rotation, to frame’s [`[[rotation]]`](#dom-videoframe-rotation-slot).
6.  If baseFlip is equal to init.[`flip`](#dom-videoframeinit-flip), assign `false` to frame’s [`[[flip]]`](#dom-videoframe-flip-slot). Otherwise, assign `true` to frame’s [`[[flip]]`](#dom-videoframe-flip-slot).
7.  If [`displayWidth`](#dom-videoframeinit-displaywidth) and [`displayHeight`](#dom-videoframeinit-displayheight) [exist](https://infra.spec.whatwg.org/#map-exists) in init, assign them to [`[[display width]]`](#dom-videoframe-display-width-slot) and [`[[display height]]`](#dom-videoframe-display-height-slot) respectively.
8.  Otherwise:
    1.  If baseRotation is equal to `0` or `180`:
        1.  Let widthScale be the result of dividing defaultDisplayWidth by defaultVisibleRect.[`width`](https://www.w3.org/TR/geometry-1/#dom-domrect-width).
        2.  Let heightScale be the result of dividing defaultDisplayHeight by defaultVisibleRect.[`height`](https://www.w3.org/TR/geometry-1/#dom-domrect-height).

    2.  Otherwise:
        1.  Let widthScale be the result of dividing defaultDisplayHeight by defaultVisibleRect.[`width`](https://www.w3.org/TR/geometry-1/#dom-domrect-width).
        2.  Let heightScale be the result of dividing defaultDisplayWidth by defaultVisibleRect.[`height`](https://www.w3.org/TR/geometry-1/#dom-domrect-height).

    3.  Let displayWidth be `|frame|'s {{VideoFrame/[[visible width]]}} * |widthScale|`, rounded to the nearest integer.
    4.  Let displayHeight be `|frame|'s {{VideoFrame/[[visible height]]}} * |heightScale|`, rounded to the nearest integer.
    5.  If rotation is equal to `0` or `180`:
        1.  Assign displayWidth to frame’s [`[[display width]]`](#dom-videoframe-display-width-slot).
        2.  Assign displayHeight to frame’s [`[[display height]]`](#dom-videoframe-display-height-slot).

    6.  Otherwise:
        1.  Assign displayHeight to frame’s [`[[display width]]`](#dom-videoframe-display-width-slot).
        2.  Assign displayWidth to frame’s [`[[display height]]`](#dom-videoframe-display-height-slot).

**Clone VideoFrame (with frame)**
: 1. Let clone be a new [`VideoFrame`](#videoframe) initialized as follows:

    1.  Let resource be the [media resource](#media-resource) referenced by frame’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).

    2.  Let newReference be a new reference to resource.

    3.  Assign newReference to clone’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).

    4.  Assign all remaining internal slots of frame (excluding [`[[resource reference]]`](#dom-videoframe-resource-reference-slot)) to those of the same name in clone.

2.  Return clone.

**Close VideoFrame (with frame)**
: 1. Assign `null` to frame’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot).

2.  Assign `true` to frame’s [`[[Detached]]`](https://html.spec.whatwg.org/multipage/structured-data.html#detached).
3.  Assign `null` to frame’s [`format`](#dom-videoframe-format).
4.  Assign `0` to frame’s [`[[coded width]]`](#dom-videoframe-coded-width-slot), [`[[coded height]]`](#dom-videoframe-coded-height-slot), [`[[visible left]]`](#dom-videoframe-visible-left-slot), [`[[visible top]]`](#dom-videoframe-visible-top-slot), [`[[visible width]]`](#dom-videoframe-visible-width-slot), [`[[visible height]]`](#dom-videoframe-visible-height-slot), [`[[rotation]]`](#dom-videoframe-rotation-slot), [`[[display width]]`](#dom-videoframe-display-width-slot), and [`[[display height]]`](#dom-videoframe-display-height-slot).
5.  Assign `false` to frame’s [`[[flip]]`](#dom-videoframe-flip-slot).
6.  Assign a new [`VideoFrameMetadata`](#dictdef-videoframemetadata) to frame.[`[[metadata]]`](#dom-videoframe-metadata-slot).

**Parse Rotation (with rotation)**
: 1. Let alignedRotation be the nearest multiple of `90` to rotation, rounding ties towards positive infinity.

2.  Let fullTurns be the greatest multiple of `360` less than or equal to alignedRotation.
3.  Return `|alignedRotation| - |fullTurns|`.

**Add Rotations (with baseRotation, baseFlip, and rotation)**
: 1. If baseFlip is `false`, let combinedRotation be `|baseRotation| + |rotation|`. Otherwise, let combinedRotation be `|baseRotation| - |rotation|`.

2.  Let fullTurns be the greatest multiple of `360` less than or equal to combinedRotation.
3.  Return `|combinedRotation| - |fullTurns|`.

**Parse VideoFrameCopyToOptions (with options)**
: 1. Let defaultRect be the result of performing the getter steps for [`visibleRect`](#dom-videoframe-visiblerect).

2.  Let overrideRect be `undefined`.
3.  If options.[`rect`](#dom-videoframecopytooptions-rect) [exists](https://infra.spec.whatwg.org/#map-exists), assign the value of options.[`rect`](#dom-videoframecopytooptions-rect) to overrideRect.
4.  Let parsedRect be the result of running the [Parse Visible Rect](#videoframe-parse-visible-rect) algorithm with defaultRect, overrideRect, [`[[coded width]]`](#dom-videoframe-coded-width-slot), [`[[coded height]]`](#dom-videoframe-coded-height-slot), and [`[[format]]`](#dom-videoframe-format-slot).
5.  If parsedRect is an exception, return parsedRect.
6.  Let optLayout be `undefined`.
7.  If options.[`layout`](#dom-videoframecopytooptions-layout) [exists](https://infra.spec.whatwg.org/#map-exists), assign its value to optLayout.
8.  Let format be `undefined`.
9.  If options.[`format`](#dom-videoframecopytooptions-format) does not [exist](https://infra.spec.whatwg.org/#map-exists), assign [`[[format]]`](#dom-videoframe-format-slot) to format.
10. Otherwise, if options.[`format`](#dom-videoframecopytooptions-format) is equal to one of [`RGBA`](#dom-videopixelformat-rgba), [`RGBX`](#dom-videopixelformat-rgbx), [`BGRA`](#dom-videopixelformat-bgra), [`BGRX`](#dom-videopixelformat-bgrx), then assign options.[`format`](#dom-videoframecopytooptions-format) to format, otherwise return [`NotSupportedError`](https://webidl.spec.whatwg.org/#notsupportederror).
11. Let combinedLayout be the result of running the [Compute Layout and Allocation Size](#videoframe-compute-layout-and-allocation-size) algorithm with parsedRect, format, and optLayout.
12. Return combinedLayout.

**Verify Rect Offset Alignment (with format and rect)**
: 1. If format is `null`, return `true`.

2.  Let planeIndex be `0`.
3.  Let numPlanes be the number of planes as defined by format.
4.  While planeIndex is less than numPlanes:
    1.  Let plane be the Plane identified by planeIndex as defined by format.
    2.  Let sampleWidth be the horizontal [sub-sampling factor](#sub-sampling-factor) of each subsample for plane.
    3.  Let sampleHeight be the vertical [sub-sampling factor](#sub-sampling-factor) of each subsample for plane.
    4.  If rect.[`x`](https://www.w3.org/TR/geometry-1/#dom-domrectreadonly-x) is not a multiple of sampleWidth, return `false`.
    5.  If rect.[`y`](https://www.w3.org/TR/geometry-1/#dom-domrectreadonly-y) is not a multiple of sampleHeight, return `false`.
    6.  Increment planeIndex by `1`.

5.  Return `true`.

**Parse Visible Rect (with defaultRect, overrideRect, codedWidth, codedHeight, and format)**
: 1. Let sourceRect be defaultRect

2.  If overrideRect is not `undefined`:
    1.  If either of overrideRect.[`width`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-width) or [`height`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-height) is `0`, return a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
    2.  If the sum of overrideRect.[`x`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-x) and overrideRect.[`width`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-width) is greater than codedWidth, return a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
    3.  If the sum of overrideRect.[`y`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-y) and overrideRect.[`height`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-height) is greater than codedHeight, return a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
    4.  Assign overrideRect to sourceRect.

3.  Let validAlignment be the result of running the [Verify Rect Offset Alignment](#videoframe-verify-rect-offset-alignment) algorithm with format and sourceRect.
4.  If validAlignment is `false`, throw a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
5.  Return sourceRect.

**Compute Layout and Allocation Size (with parsedRect, format, and layout)**
: 1. Let numPlanes be the number of planes as defined by format.

2.  If layout is not `undefined` and its length does not equal numPlanes, throw a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
3.  Let minAllocationSize be `0`.
4.  Let computedLayouts be a new [list](https://infra.spec.whatwg.org/#list).
5.  Let endOffsets be a new [list](https://infra.spec.whatwg.org/#list).
6.  Let planeIndex be `0`.
7.  While planeIndex < numPlanes:
    1.  Let plane be the Plane identified by planeIndex as defined by format.
    2.  Let sampleBytes be the number of bytes per sample for plane.
    3.  Let sampleWidth be the horizontal [sub-sampling factor](#sub-sampling-factor) of each subsample for plane.
    4.  Let sampleHeight be the vertical [sub-sampling factor](#sub-sampling-factor) of each subsample for plane.
    5.  Let computedLayout be a new [computed plane layout](#computed-plane-layout).
    6.  Set computedLayout’s [sourceTop](#computed-plane-layout-sourcetop) to the result of the division of truncated parsedRect.[`y`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-y) by sampleHeight, rounded up to the nearest integer.
    7.  Set computedLayout’s [sourceHeight](#computed-plane-layout-sourceheight) to the result of the division of truncated parsedRect.[`height`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-height) by sampleHeight, rounded up to the nearest integer.
    8.  Set computedLayout’s [sourceLeftBytes](#computed-plane-layout-sourceleftbytes) to the result of the integer division of truncated parsedRect.[`x`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-x) by sampleWidth, multiplied by sampleBytes.
    9.  Set computedLayout’s [sourceWidthBytes](#computed-plane-layout-sourcewidthbytes) to the result of the integer division of truncated parsedRect.[`width`](https://www.w3.org/TR/geometry-1/#dom-domrectinit-width) by sampleWidth, multiplied by sampleBytes.
    10. If layout is not `undefined`:
        1.  Let planeLayout be the [`PlaneLayout`](#dictdef-planelayout) in layout at position planeIndex.
        2.  If planeLayout.[`stride`](#dom-planelayout-stride) is less than computedLayout’s [sourceWidthBytes](#computed-plane-layout-sourcewidthbytes), return a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
        3.  Assign planeLayout.[`offset`](#dom-planelayout-offset) to computedLayout’s [destinationOffset](#computed-plane-layout-destinationoffset).
        4.  Assign planeLayout.[`stride`](#dom-planelayout-stride) to computedLayout’s [destinationStride](#computed-plane-layout-destinationstride).

    11. Otherwise:

        NOTE: If an explicit layout was not provided, the following steps default to tight packing.
        1.  Assign minAllocationSize to computedLayout’s [destinationOffset](#computed-plane-layout-destinationoffset).
        2.  Assign computedLayout’s [sourceWidthBytes](#computed-plane-layout-sourcewidthbytes) to computedLayout’s [destinationStride](#computed-plane-layout-destinationstride).

    12. Let planeSize be the product of multiplying computedLayout’s [destinationStride](#computed-plane-layout-destinationstride) and [sourceHeight](#computed-plane-layout-sourceheight).
    13. Let planeEnd be the sum of planeSize and computedLayout’s [destinationOffset](#computed-plane-layout-destinationoffset).
    14. If planeSize or planeEnd is greater than maximum range of [`unsigned long`](https://webidl.spec.whatwg.org/#idl-unsigned-long), return a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
    15. Append planeEnd to endOffsets.
    16. Assign the maximum of minAllocationSize and planeEnd to minAllocationSize.

        NOTE: The above step uses a maximum to allow for the possibility that user specified plane offsets reorder planes.

    17. Let earlierPlaneIndex be `0`.
    18. While earlierPlaneIndex is less than planeIndex.
        1.  Let earlierLayout be `computedLayouts[earlierPlaneIndex]`.
        2.  If `endOffsets[planeIndex]` is less than or equal to earlierLayout’s [destinationOffset](#computed-plane-layout-destinationoffset) or if `endOffsets[earlierPlaneIndex]` is less than or equal to computedLayout’s [destinationOffset](#computed-plane-layout-destinationoffset), continue.

            NOTE: If plane A ends before plane B starts, they do not overlap.

        3.  Otherwise, return a [`TypeError`](https://webidl.spec.whatwg.org/#exceptiondef-typeerror).
        4.  Increment earlierPlaneIndex by `1`.

    19. Append computedLayout to computedLayouts.
    20. Increment planeIndex by `1`.

8.  Let combinedLayout be a new [combined buffer layout](#combined-buffer-layout), initialized as follows:
    1.  Assign computedLayouts to [computedLayouts](#combined-buffer-layout-computedlayouts).
    2.  Assign minAllocationSize to [allocationSize](#combined-buffer-layout-allocationsize).

9.  Return combinedLayout.

**Convert PredefinedColorSpace to VideoColorSpace (with colorSpace)**
: 1. Assert: colorSpace is equal to one of [`srgb`](https://html.spec.whatwg.org/multipage/canvas.html#dom-predefinedcolorspace-srgb) or [`display-p3`](https://html.spec.whatwg.org/multipage/canvas.html#dom-predefinedcolorspace-display-p3).

2.  If colorSpace is equal to [`srgb`](https://html.spec.whatwg.org/multipage/canvas.html#dom-predefinedcolorspace-srgb) return a new instance of the [sRGB Color Space](#srgb-color-space)
3.  If colorSpace is equal to [`display-p3`](https://html.spec.whatwg.org/multipage/canvas.html#dom-predefinedcolorspace-display-p3) return a new instance of the [Display P3 Color Space](#display-p3-color-space)

**Convert to RGB frame (with frame, format and colorSpace)**
: 1. This algorithm _MUST_ be called only if format is equal to one of [`RGBA`](#dom-videopixelformat-rgba), [`RGBX`](#dom-videopixelformat-rgbx), [`BGRA`](#dom-videopixelformat-bgra), [`BGRX`](#dom-videopixelformat-bgrx).

2.  Let convertedFrame be a new [`VideoFrame`](#videoframe), constructed as follows:
    1.  Assign `false` to [`[[Detached]]`](https://html.spec.whatwg.org/multipage/structured-data.html#detached).
    2.  Assign format to [`[[format]]`](#dom-videoframe-format-slot).
    3.  Let width be frame’s [`[[visible width]]`](#dom-videoframe-visible-width-slot).
    4.  Let height be frame’s [`[[visible height]]`](#dom-videoframe-visible-height-slot).
    5.  Assign width, height, 0, 0, width, height, width, and height to [`[[coded width]]`](#dom-videoframe-coded-width-slot), [`[[coded height]]`](#dom-videoframe-coded-height-slot), [`[[visible left]]`](#dom-videoframe-visible-left-slot), [`[[visible top]]`](#dom-videoframe-visible-top-slot), [`[[visible width]]`](#dom-videoframe-visible-width-slot), and [`[[visible height]]`](#dom-videoframe-visible-height-slot) respectively.
    6.  Assign frame’s [`[[duration]]`](#dom-videoframe-duration-slot) and frame’s [`[[timestamp]]`](#dom-videoframe-timestamp-slot) to [`[[duration]]`](#dom-videoframe-duration-slot) and [`[[timestamp]]`](#dom-videoframe-timestamp-slot) respectively.
    7.  Assign the result of running the [Convert PredefinedColorSpace to VideoColorSpace](#convert-predefinedcolorspace-to-videocolorspace) algorithm with colorSpace to [`[[color space]]`](#dom-videoframe-color-space-slot).
    8.  Let resource be a new [media resource](#media-resource) containing the result of conversion of [media resource](#media-resource) referenced by frame’s [`[[resource reference]]`](#dom-videoframe-resource-reference-slot) into a color space and pixel format specified by [`[[color space]]`](#dom-videoframe-color-space-slot) and [`[[format]]`](#dom-videoframe-format-slot) respectively.
    9.  Assign the reference to resource to [`[[resource reference]]`](#dom-videoframe-resource-reference-slot)

3.  Return convertedFrame.

**Copy VideoFrame metadata (with metadata)**
: 1. Let metadataCopySerialized be [StructuredSerialize](https://html.spec.whatwg.org/multipage/structured-data.html#structuredserialize)(metadata).

2.  Let metadataCopy be [StructuredDeserialize](https://html.spec.whatwg.org/multipage/structured-data.html#structureddeserialize)(metadataCopySerialized, [the current Realm](https://tc39.es/ecma262/#current-realm)).
3.  Return metadataCopy.

The goal of this algorithm is to ensure that metadata owned by a [`VideoFrame`](#videoframe) is immutable.

---

[← Back to 9.4. VideoFrame Interface](../../9-raw-media-interfaces/9.4-videoframe-interface/TOC.md)
