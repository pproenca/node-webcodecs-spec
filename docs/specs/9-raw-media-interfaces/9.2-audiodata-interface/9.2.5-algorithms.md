# 9.2.5. Algorithms

**Compute Copy Element Count (with options)**
: Run these steps:

1.  Let destFormat be the value of [`[[format]]`](#dom-audiodata-format-slot).
    
2.  If options.[`format`](#dom-audiodatacopytooptions-format) [exists](https://infra.spec.whatwg.org/#map-exists), assign options.[`format`](#dom-audiodatacopytooptions-format) to destFormat.
    
3.  If destFormat describes an [interleaved](#interleaved) [`AudioSampleFormat`](#enumdef-audiosampleformat) and options.[`planeIndex`](#dom-audiodatacopytooptions-planeindex) is greater than `0`, throw a [`RangeError`](https://webidl.spec.whatwg.org/#exceptiondef-rangeerror).
    
4.  Otherwise, if destFormat describes a [planar](#planar) [`AudioSampleFormat`](#enumdef-audiosampleformat) and if options.[`planeIndex`](#dom-audiodatacopytooptions-planeindex) is greater or equal to [`[[number of channels]]`](#dom-audiodata-number-of-channels-slot), throw a [`RangeError`](https://webidl.spec.whatwg.org/#exceptiondef-rangeerror).
    
5.  If [`[[format]]`](#dom-audiodata-format-slot) does not equal destFormat and the User Agent does not support the requested [`AudioSampleFormat`](#enumdef-audiosampleformat) conversion, throw a [`NotSupportedError`](https://webidl.spec.whatwg.org/#notsupportederror) [`DOMException`](https://webidl.spec.whatwg.org/#idl-DOMException). Conversion to [`f32-planar`](#dom-audiosampleformat-f32-planar) _MUST_ always be supported.
    
6.  Let frameCount be the number of frames in the plane identified by options.[`planeIndex`](#dom-audiodatacopytooptions-planeindex).
    
7.  If options.[`frameOffset`](#dom-audiodatacopytooptions-frameoffset) is greater than or equal to frameCount, throw a [`RangeError`](https://webidl.spec.whatwg.org/#exceptiondef-rangeerror).
    
8.  Let copyFrameCount be the difference of subtracting options.[`frameOffset`](#dom-audiodatacopytooptions-frameoffset) from frameCount.
    
9.  If options.[`frameCount`](#dom-audiodatacopytooptions-framecount) [exists](https://infra.spec.whatwg.org/#map-exists):
    
    1.  If options.[`frameCount`](#dom-audiodatacopytooptions-framecount) is greater than copyFrameCount, throw a [`RangeError`](https://webidl.spec.whatwg.org/#exceptiondef-rangeerror).
        
    2.  Otherwise, assign options.[`frameCount`](#dom-audiodatacopytooptions-framecount) to copyFrameCount.
        
10.  Let elementCount be copyFrameCount.
     
11.  If destFormat describes an [interleaved](#interleaved) [`AudioSampleFormat`](#enumdef-audiosampleformat), multiply elementCount by [`[[number of channels]]`](#dom-audiodata-number-of-channels-slot)
     
12.  return elementCount.

**Clone AudioData (with data)**
: Run these steps:

1.  Let clone be a new [`AudioData`](#audiodata) initialized as follows:
    
    1.  Let resource be the [media resource](#media-resource) referenced by data’s [`[[resource reference]]`](#dom-audiodata-resource-reference-slot).
        
    2.  Let reference be a new reference to resource.
        
    3.  Assign reference to [`[[resource reference]]`](#dom-audiodata-resource-reference-slot).
        
    4.  Assign the values of data’s [`[[Detached]]`](https://html.spec.whatwg.org/multipage/structured-data.html#detached), [`[[format]]`](#dom-audiodata-format-slot), [`[[sample rate]]`](#dom-audiodata-sample-rate-slot), [`[[number of frames]]`](#dom-audiodata-number-of-frames-slot), [`[[number of channels]]`](#dom-audiodata-number-of-channels-slot), and [`[[timestamp]]`](#dom-audiodata-timestamp-slot) slots to the corresponding slots in clone.
        
2.  Return clone.

**Close AudioData (with data)**
: Run these steps:

1.  Assign `true` to data’s [`[[Detached]]`](https://html.spec.whatwg.org/multipage/structured-data.html#detached) internal slot.
    
2.  Assign `null` to data’s [`[[resource reference]]`](#dom-audiodata-resource-reference-slot).
    
3.  Assign `0` to data’s [`[[sample rate]]`](#dom-audiodata-sample-rate-slot).
    
4.  Assign `0` to data’s [`[[number of frames]]`](#dom-audiodata-number-of-frames-slot).
    
5.  Assign `0` to data’s [`[[number of channels]]`](#dom-audiodata-number-of-channels-slot).
    
6.  Assign `null` to data’s [`[[format]]`](#dom-audiodata-format-slot).

**To check if a AudioDataInit is a valid AudioDataInit, run these steps:**
: 1.  If [`sampleRate`](#dom-audiodatainit-samplerate) less than or equal to `0`, return `false`.
    
2.  If [`numberOfFrames`](#dom-audiodatainit-numberofframes) = `0`, return `false`.
    
3.  If [`numberOfChannels`](#dom-audiodatainit-numberofchannels) = `0`, return `false`.
    
4.  Verify [`data`](#dom-audiodatainit-data) has enough data by running the following steps:
    
    1.  Let totalSamples be the product of multiplying [`numberOfFrames`](#dom-audiodatainit-numberofframes) by [`numberOfChannels`](#dom-audiodatainit-numberofchannels).
        
    2.  Let bytesPerSample be the number of bytes per sample, as defined by the [`format`](#dom-audiodatainit-format).
        
    3.  Let totalSize be the product of multiplying bytesPerSample with totalSamples.
        
    4.  Let dataSize be the size in bytes of [`data`](#dom-audiodatainit-data).
        
    5.  If dataSize is less than totalSize, return false.
        
5.  Return `true`.

Note: It’s expected that [`AudioDataInit`](#dictdef-audiodatainit)’s [`data`](#dom-audiodatainit-data)’s memory layout matches the expectations of the [planar](#planar) or [interleaved](#interleaved) [`format`](#dom-audiodatainit-format). There is no real way to verify whether the samples conform to their [`AudioSampleFormat`](#enumdef-audiosampleformat).

---

[← Back to 9.2. AudioData Interface](../../9-raw-media-interfaces/9.2-audiodata-interface/TOC.md)
